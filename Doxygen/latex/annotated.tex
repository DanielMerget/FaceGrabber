\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class_buffer}{Buffer$<$ Data\+Type $>$} \\*A buffer which allows to push new data and pull it afterwards. The buffer allows multiple threads to push data. Pulling of data blocks until new data is available. Pusing of data blocks until there is a free element in buffer }{\pageref{class_buffer}}{}
\item\contentsline{section}{\hyperlink{class_buffer_synchronizer}{Buffer\+Synchronizer$<$ Buffer\+Data\+Type $>$} \\*The \hyperlink{class_buffer_synchronizer}{Buffer\+Synchronizer} synchronizes the data that can be pulled from given buffers\+: The \hyperlink{class_buffer_synchronizer}{Buffer\+Synchronizer} waits until data is available on all buffers. Afterwards, the data is pulled and provided via the publish\+Synchronized\+Data signal. \hyperlink{class_buffer_synchronizer}{Buffer\+Synchronizer} is supposed to run in its threading function update\+Thread\+Func }{\pageref{class_buffer_synchronizer}}{}
\item\contentsline{section}{\hyperlink{struct_cloud_file}{Cloud\+File} }{\pageref{struct_cloud_file}}{}
\item\contentsline{section}{\hyperlink{class_cloud_measurement_source}{Cloud\+Measurement\+Source$<$ Point\+Cloud\+Type $>$} \\*A cloud measurement source allows to pull Point\+Cloud\+Measurements }{\pageref{class_cloud_measurement_source}}{}
\item\contentsline{section}{\hyperlink{class_colored_output_stream_updater}{Colored\+Output\+Stream\+Updater} \\*The \hyperlink{class_colored_output_stream_updater}{Colored\+Output\+Stream\+Updater} takes the buffers and face information provided by the update\+Output\+Streams, extracts the H\+D\+Face, Face\+Raw and Full\+Raw\+Depth point clouds and publishes them via clouds\+Updated or cloud\+Updated. Beforehand the \hyperlink{class_colored_output_stream_updater}{Colored\+Output\+Stream\+Updater} has to be initialied with the coordinatemapper provided by the kinect and information about the resolution of the update-\/streams }{\pageref{class_colored_output_stream_updater}}{}
\item\contentsline{section}{\hyperlink{class_convert_tab_handler}{Convert\+Tab\+Handler} \\*The class handling user inputs of the conversion tab. Conversion configuration is saved in the \hyperlink{class_playback_configuration}{Playback\+Configuration} and \hyperlink{class_simple_recording_configuration}{Simple\+Recording\+Configuration} data structure. On Request of the user the \hyperlink{class_convert_tab_handler}{Convert\+Tab\+Handler} runs the conversion of files by using an independent dataflow of P\+C\+L\+File\+Input\+Reader, \hyperlink{class_buffer}{Buffer}, \hyperlink{class_buffer_synchronizer}{Buffer\+Synchronizer} and \hyperlink{class_kinect_cloud_file_writer}{Kinect\+Cloud\+File\+Writer} }{\pageref{class_convert_tab_handler}}{}
\item\contentsline{section}{\hyperlink{class_h_d_face_visualizer_1_1_direct_x_panel_base}{H\+D\+Face\+Visualizer\+::\+Direct\+X\+Panel\+Base} }{\pageref{class_h_d_face_visualizer_1_1_direct_x_panel_base}}{}
\item\contentsline{section}{\hyperlink{class_image_renderer}{Image\+Renderer} }{\pageref{class_image_renderer}}{}
\item\contentsline{section}{\hyperlink{class_i_recording_configuration}{I\+Recording\+Configuration} \\*The recording configuration interface provides all information required by the Kinect\+Cloud\+Output\+Writer to record point clouds to the hard disc }{\pageref{class_i_recording_configuration}}{}
\item\contentsline{section}{\hyperlink{class_kinect_cloud_file_writer}{Kinect\+Cloud\+File\+Writer$<$ Point\+Cloud\+Type $>$} \\*A kinect cloud output writer which writes Point Clouds to the hard disk according to the set Configuration. Writing can be done multi-\/threaded }{\pageref{class_kinect_cloud_file_writer}}{}
\item\contentsline{section}{\hyperlink{class_kinect_file_writer_thread}{Kinect\+File\+Writer\+Thread$<$ Point\+Cloud\+Type $>$} \\*A kinect file writer thread supposed to write Point Cloud files in the given generates to the hard disk. Cloud\+Measurements are pulled from the set source }{\pageref{class_kinect_file_writer_thread}}{}
\item\contentsline{section}{\hyperlink{class_kinect_h_d_face_grabber}{Kinect\+H\+D\+Face\+Grabber} \\*\hyperlink{class_kinect_h_d_face_grabber}{Kinect\+H\+D\+Face\+Grabber} uses the Kinect v2 to process the users faces found and tracked by the Kinect A\+P\+I. With the set \hyperlink{class_output_streams_updater_stragedy}{Output\+Streams\+Updater\+Stragedy} the information about the faces found by H\+D\+Face A\+P\+I can be further processed. The \hyperlink{class_kinect_h_d_face_grabber}{Kinect\+H\+D\+Face\+Grabber} initializes the Depth, Color and H\+D\+Face Reader and grabs the frames provided by the the reades each time the \hyperlink{class_kinect_h_d_face_grabber_a619b994aaca778dd7d8ce180b59a6667}{update()} method is called. The current color camera image with the tracked face points are render using the set \hyperlink{class_image_renderer}{Image\+Renderer} }{\pageref{class_kinect_h_d_face_grabber}}{}
\item\contentsline{section}{\hyperlink{class_message_router_helper}{Message\+Router\+Helper} \\*A message router helper which filters for the most important events the user triggers while using the user interface }{\pageref{class_message_router_helper}}{}
\item\contentsline{section}{\hyperlink{struct_d_x_1_1_model_view_projection_constant_buffer}{D\+X\+::\+Model\+View\+Projection\+Constant\+Buffer} }{\pageref{struct_d_x_1_1_model_view_projection_constant_buffer}}{}
\item\contentsline{section}{\hyperlink{class_output_streams_updater_stragedy}{Output\+Streams\+Updater\+Stragedy} \\*The \hyperlink{class_output_streams_updater_stragedy}{Output\+Streams\+Updater\+Stragedy} defines method stubs which should called by the \hyperlink{class_kinect_h_d_face_grabber}{Kinect\+H\+D\+Face\+Grabber} for each new Face\+Frame. Inherited classes can use the provided data to run various algorithmns. start\+Face\+Collection should be called before calling update\+Output\+Streams for tracked Kinect-\/\+Face\+Frame. Afterwards stop\+Face\+Collection should be called. \hyperlink{class_output_streams_updater_stragedy}{Output\+Streams\+Updater\+Stragedy} hides the implementation to allow switching the implementation at run time }{\pageref{class_output_streams_updater_stragedy}}{}
\item\contentsline{section}{\hyperlink{class_p_c_l_input_reader}{P\+C\+L\+Input\+Reader$<$ Point\+Type $>$} \\*The \hyperlink{class_p_c_l_input_reader}{P\+C\+L\+Input\+Reader} is able to read point cloud files (ply, pcd) multi-\/threaded or single-\/threaded. The files to be read must be specified a \hyperlink{class_playback_configuration}{Playback\+Configuration}. Having started the reading, the files are stored in the given buffer which provides them for further processing. T\+He \hyperlink{class_p_c_l_input_reader}{P\+C\+L\+Input\+Reader} resizes the \hyperlink{class_buffer}{Buffer} to save all read files. So the \hyperlink{class_buffer}{Buffer} will have the same size as number of files to be read }{\pageref{class_p_c_l_input_reader}}{}
\item\contentsline{section}{\hyperlink{class_p_c_l_input_reader_worker_thread}{P\+C\+L\+Input\+Reader\+Worker\+Thread$<$ Point\+Type $>$} \\*A P\+C\+L input reader worker object used by the \hyperlink{class_p_c_l_input_reader}{P\+C\+L\+Input\+Reader} to read point cloud files (ply, pcd) }{\pageref{class_p_c_l_input_reader_worker_thread}}{}
\item\contentsline{section}{\hyperlink{class_p_c_l_viewer}{P\+C\+L\+Viewer} \\*The P\+C\+L viewer is able to render Point Clouds using the P\+C\+L\+Visualizer. The \hyperlink{class_p_c_l_viewer}{P\+C\+L\+Viewer} extends the P\+C\+L\+Visualizer by enabling multi-\/threaded updating of the point clouds. Furthermore, dynamic switching between colored and non-\/colored clouds, as well as changing the amount of viewports is supported }{\pageref{class_p_c_l_viewer}}{}
\item\contentsline{section}{\hyperlink{class_playback_configuration}{Playback\+Configuration} \\*\hyperlink{class_playback_configuration}{Playback\+Configuration} stores all information required by the Input\+Reader to read point cloud files from the disc }{\pageref{class_playback_configuration}}{}
\item\contentsline{section}{\hyperlink{class_playback_tab_handler}{Playback\+Tab\+Handler} \\*The Class handling all events of the user to configure the \hyperlink{class_playback_configuration}{Playback\+Configuration}. If requested by the user, the playback is triggered by fireing the start\+Playback, stop\+Playback signals etc }{\pageref{class_playback_tab_handler}}{}
\item\contentsline{section}{\hyperlink{class_point_cloud_measurement}{Point\+Cloud\+Measurement$<$ Measurement\+Cloud\+Type $>$} \\*A point cloud measurement encapsulating a point cloud and the index when it was captured }{\pageref{class_point_cloud_measurement}}{}
\item\contentsline{section}{\hyperlink{class_recording_configuration}{Recording\+Configuration} \\*The Recording Configuration stores all information neccessary to the \hyperlink{class_kinect_cloud_file_writer}{Kinect\+Cloud\+File\+Writer} to save ply and pcd files to the directory. It allows to specify the directory for the files and automatically searches for the files. It constructs the directory path to save the point clouds in the following way\+: //outputfolder/timestamp/cloudtype/filename.fileformat }{\pageref{class_recording_configuration}}{}
\item\contentsline{section}{\hyperlink{class_record_tab_handler}{Record\+Tab\+Handler} \\*Record\+Tab\+Handle handles all user inputs and configures the \hyperlink{class_recording_configuration}{Recording\+Configuration} used to record point cloud files. If requested by the user, the \hyperlink{class_record_tab_handler}{Record\+Tab\+Handler} fires the start\+Writing and stop\+Writing signals providing the \hyperlink{class_recording_configuration}{Recording\+Configuration} }{\pageref{class_record_tab_handler}}{}
\item\contentsline{section}{\hyperlink{class_simple_recording_configuration}{Simple\+Recording\+Configuration} \\*A simple recording configuration which allows to specify only the required attributes manually. In contrast to \hyperlink{class_recording_configuration}{Recording\+Configuration} no concatenation of outputfolder, timestamps etc. is done here }{\pageref{class_simple_recording_configuration}}{}
\item\contentsline{section}{\hyperlink{class_d_x_1_1_step_timer}{D\+X\+::\+Step\+Timer} }{\pageref{class_d_x_1_1_step_timer}}{}
\item\contentsline{section}{\hyperlink{class_uncolored_output_streams_updater}{Uncolored\+Output\+Streams\+Updater} \\*Implementation of the \hyperlink{class_output_streams_updater_stragedy}{Output\+Streams\+Updater\+Stragedy} which extracts point clouds using the buffers provided method calls. The processed point clouds are provided without colored. Listeners can registered on clouds\+Updated and cloud\+Updated. Clouds\+Updated provides the H\+D\+Face and Raw\+Face\+Depth point clouds. cloud\+Updated\mbox{[}0\mbox{]}\+: H\+D\+Face cloud\+Updated\mbox{[}1\mbox{]}\+: Raw\+Face\+Depth cloud\+Updated\mbox{[}2\mbox{]}\+: Full\+Rawp\+Deth }{\pageref{class_uncolored_output_streams_updater}}{}
\item\contentsline{section}{\hyperlink{struct_d_x_1_1_vertex_position_color}{D\+X\+::\+Vertex\+Position\+Color} }{\pageref{struct_d_x_1_1_vertex_position_color}}{}
\item\contentsline{section}{\hyperlink{struct_d_x_1_1_vertex_position_color_normal}{D\+X\+::\+Vertex\+Position\+Color\+Normal} }{\pageref{struct_d_x_1_1_vertex_position_color_normal}}{}
\item\contentsline{section}{\hyperlink{class_windows_app_dialog_helper}{Windows\+App\+Dialog\+Helper} \\*The windows application dialog helper for opening file/directory dialogs }{\pageref{class_windows_app_dialog_helper}}{}
\item\contentsline{section}{\hyperlink{class_windows_application}{Windows\+Application} \\*The windows application holds the \hyperlink{class_kinect_h_d_face_grabber}{Kinect\+H\+D\+Face\+Grabber}, File\+Reader and Writer and processes the users input. It constructs the Dataflows neccessary for recording and playing the point cloud files }{\pageref{class_windows_application}}{}
\end{DoxyCompactList}
